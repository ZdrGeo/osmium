<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>View</title>
</head>
<body>
    <div><strong>Analysis:</strong> {{ .Name }}</div>
    <div class="view" style="margin: 20px; padding: 20px; border: 1px solid black; width: max-content; height: max-content;"></div>
    <script type="module">
        import * as d3 from 'https://cdn.jsdelivr.net/npm/d3@7/+esm';

        // https://observablehq.com/@stanfordvis/making-d3-charts-interactive
        const spanName = '';

        const view = await d3.json('view.json');

        const cellWidth = 20;
        const cellHeight = 20;

        const generateCells =
            (xL, yL) => new Array(yL).fill(null).map(
                (y, yI) => new Array(xL).fill(null).map(
                    (x, xI) => ({
                        i: yI * yL + xI,
                        xI: xI,
                        yI: yI,
                        color: 'white',
                        value: null
                    })
                )
            );

        const renderCell = (g, width, height, color, value) => {
            g.append('rect')
                .style('stroke', 'black')
                .attr('fill', color)
                .attr('rx', 0)
                .attr('ry', 0)
                .attr('width', width)
                .attr('height', height);

            g.append('text')
                .text(value)
                .attr('font-family', 'sans-serif')
                .attr('font-size', 8)
                .attr('text-anchor', 'middle')
                .attr('x', width / 2)
                .attr('y', 16)
                .attr('width', width)
                .attr('height', height);

            return g;
        };

        const renderCells = (xL, yL, cellWidth, cellHeight, cells) => {
            function onMouseOver() {
                const cell = d3.select(this).datum();
            };

            function onMouseLeave() {
            };

            const x = d3
                .scaleLinear()
                .domain([0, xL - 1])
                .range([0, (xL - 1) * cellWidth]);

            const y = d3
                .scaleLinear()
                .domain([0, yL - 1])
                .range([0, (yL - 1) * cellHeight]);

            d3
                .select('.view > svg')
                .remove();

            const svg = d3
                .select('.view')
                .append('svg')
                    .attr("width", xL * cellWidth + 40)
                    .attr("height", yL * cellHeight + 40);

            svg.append("g")
                .attr("transform", `translate(30, 20)`)
                .call(d3.axisTop(x).ticks(xL).tickSize(0));

            svg.append("g")
                .attr("transform", `translate(30, ${yL * cellWidth + 20})`)
                .call(d3.axisBottom(x).ticks(xL).tickSize(0));

            svg.append("g")
                .attr("transform", `translate(20, 30)`)
                .call(d3.axisLeft(y).ticks(yL).tickSize(0));

            svg.append("g")
                .attr("transform", `translate(${xL * cellHeight + 20}, 30)`)
                .call(d3.axisRight(y).ticks(yL).tickSize(0));

            const packNodes = svg
                .selectAll('.pack')
                .data(cells)
                .enter()
                .append('g')
                    .attr('class', 'pack')
                    .attr('transform', c => `translate(20, 20)`);

            const cellNodes = packNodes
                .selectAll('.cell')
                .data(c => c)
                .enter()
                .append('g')
                    .attr('class', 'cell')
                    .attr('transform', c => `translate(${c.xI * cellWidth}, ${c.yI * cellHeight})`)
                    .each((c, i, nodes) => renderCell(d3.select(nodes[i]), cellWidth, cellHeight, c.color, c.value).on("mouseover", onMouseOver).on("mouseleave", onMouseLeave));
        };

        const applyValues = (cells, values, valueColor) => {
            for (let yI = 0; yI < cells.length; yI++) {
                for (let xI = 0; xI < cells[yI].length; xI++) {
                    if (xI != yI) {
                        cells[yI][xI].color = valueColor(values[yI][xI]);
                        cells[yI][xI].value = values[yI][xI];
                    } else {
                        cells[yI][xI].color = 'lightgray';
                        cells[yI][xI].value = null;
                    }
                }
            }
        };

        const cells = generateCells(view.NodeNames.length, view.NodeNames.length);

        // #00afff, #5fafff, #87afff, #afafff, #d7afff, #ffafff

        const valueColor = d3
            .scaleLinear()
            .domain([view.SpanViews[spanName].MinValue, view.SpanViews[spanName].MaxValue])
            .range(['lightgreen', 'red']);

        applyValues(cells, view.SpanViews[spanName].Values, valueColor);

        renderCells(view.NodeNames.length, view.NodeNames.length, cellWidth, cellHeight, cells);
    </script>
</body>
</html>